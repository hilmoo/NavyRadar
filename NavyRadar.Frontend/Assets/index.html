<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>NavyRadar</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #map {
            height: 100vh;
            width: 100vw;
            display: block;
        }

        .leaflet-control-refresh-btn:hover {
            background-color: #f4f4f4;
        }

        .port-icon {
            background: transparent;
            border: none;
        }

        #loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            display: none;
            align-items: center;
            pointer-events: none;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #ccc;
            border-top-color: #333;
            border-radius: 50%;
            margin-right: 8px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

<div id="map"></div>

<div id="loading-indicator">
    <div class="spinner"></div>
    <span>Updating Data...</span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const loaderElement = document.getElementById('loading-indicator');
    let activeRequests = 0;

    function showLoader() {
        activeRequests++;
        loaderElement.style.display = 'flex';
    }

    function hideLoader() {
        activeRequests--;
        if (activeRequests <= 0) {
            activeRequests = 0;
            loaderElement.style.display = 'none';
        }
    }

    const map = L.map('map', {
        worldCopyJump: false,
        maxBounds: [
            [-85, -180],
            [85, 180]
        ],
        maxBoundsViscosity: 1.0,
        minZoom: 3,
        maxZoom: 19
    }).setView([-7.49, 110.0], 7);

    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        noWrap: true,
        bounds: [
            [-85, -180],
            [85, 180]
        ],
        minZoom: 2,
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    L.Control.Refresh = L.Control.extend({
        onAdd: function (map) {
            var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
            var button = L.DomUtil.create('a', 'leaflet-control-refresh-btn', container);
            button.href = '#';
            button.title = 'Refresh Ships & Ports';
            button.role = 'button';
            button.innerHTML = 'â†»';

            button.style.fontSize = '22px';
            button.style.fontWeight = 'bold';
            button.style.width = '30px';
            button.style.height = '30px';
            button.style.lineHeight = '30px';
            button.style.textAlign = 'center';
            button.style.textDecoration = 'none';
            button.style.color = 'black';
            button.style.display = 'block';
            button.style.backgroundColor = 'white';
            button.style.cursor = 'pointer';

            L.DomEvent.on(button, 'click', function (e) {
                L.DomEvent.stop(e);
                console.log("Manual refresh triggered.");
                loadShips();
                loadPorts();
            });

            L.DomEvent.disableClickPropagation(container);
            return container;
        }
    });
    new L.Control.Refresh({position: 'topleft'}).addTo(map);


    const portLayer = L.layerGroup().addTo(map);

    const portIcon = L.divIcon({
        className: 'port-icon',
        html: `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="12" fill="white"/>
          <path fill="#4361EE" d="M13 9V7.82C14.16 7.4 15 6.3 15 5c0-1.65-1.35-3-3-3S9 3.35 9 5c0 1.3.84 2.4 2 2.82V9H9c-.55 0-1 .45-1 1s.45 1 1 1h2v8.92c-2.22-.33-4.59-1.68-5.55-3.37l1.14-1.14c.22-.22.19-.57-.05-.75L3.8 12.6a.5.5 0 0 0-.8.4v2c0 3.88 4.92 7 9 7s9-3.12 9-7v-2a.5.5 0 0 0-.8-.4l-2.74 2.05c-.24.18-.27.54-.05.75l1.14 1.14c-.96 1.69-3.33 3.04-5.55 3.37V11h2c.55 0 1-.45 1-1s-.45-1-1-1zm-1-5c.55 0 1 .45 1 1s-.45 1-1 1s-1-.45-1-1s.45-1 1-1" />
        </svg>
        `,
        iconSize: [24, 24],
        iconAnchor: [12, 12]
    });

    async function loadPorts() {
        showLoader();
        try {
            const res = await fetch('http://localhost:5000/api/Ports');
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            const apiPorts = await res.json();

            portLayer.clearLayers();

            apiPorts.forEach(port => {
                const lat = port.location.y;
                const lon = port.location.x;
                const name = port.name;

                const m = L.marker([lat, lon], {icon: portIcon});

                m.bindTooltip(name);
                m.addTo(portLayer);
                m.on('click', () => {
                    const portId = port.id;
                    window.chrome.webview.postMessage({
                        type: 'portSelected',
                        id: portId
                    });
                });
            });

        } catch (err) {
            console.error('Error loading ports:', err);
        } finally {
            hideLoader();
        }
    }


    const shipLayer = L.layerGroup().addTo(map);
    const markers = new Map();

    function getShipTypeKey(shipType) {
        if (!shipType) return '';
        return shipType.replace(/\s+/g, '');
    }

    let currentFilter = {
        shipName: '',
        types: null
    };

    function upsertShip(sail) {
        const id = sail.shipId;

        const style = {
            radius: 6,
            color: '#ffffff',
            weight: 2,
            fillColor: '#ff0000',
            fillOpacity: 0.9
        };

        const lat = sail.coordinates.y;
        const lon = sail.coordinates.x;
        const m = L.circleMarker([lat, lon], style);

        m.bindTooltip(sail.shipName);

        m.on('click', () => {
            window.chrome.webview.postMessage({
                type: 'shipSelected',
                shipId: sail.shipId,
                sailId: sail.sailId
            });
        });

        m.addTo(shipLayer);
        markers.set(id, m);
    }

    function hasActiveTypes(typesObj) {
        if (!typesObj || typeof typesObj !== 'object') return false;
        return Object.values(typesObj).some(v => v === true);
    }

    async function loadShips() {
        showLoader();
        try {
            const res = await fetch('http://localhost:5000/api/Sails/active');
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            const apiSails = await res.json();

            shipLayer.clearLayers();
            markers.clear();

            const filteredSails = apiSails.filter(sail => {
                const nameFilter = (currentFilter.shipName || '').toLowerCase();
                const shipName = (sail.shipName || '').toLowerCase();
                const nameMatch = shipName.includes(nameFilter);

                let typeMatch = true;
                if (currentFilter.types && hasActiveTypes(currentFilter.types)) {
                    const typeKey = getShipTypeKey(sail.shipType);
                    typeMatch = currentFilter.types[typeKey] === true;
                }

                return nameMatch && typeMatch;
            });

            filteredSails.forEach(sail => upsertShip(sail));

        } catch (err) {
            console.error('Error loading ships:', err);
        } finally {
            hideLoader();
        }
    }

    function filterShip(message) {
        console.log("Applying filter:", message);

        if (!message || Object.keys(message).length === 0) {
            currentFilter.shipName = '';
            currentFilter.types = null;
        } else {
            currentFilter.shipName = message.shipName || '';

            if (message.types && typeof message.types === 'object' && hasActiveTypes(message.types)) {
                currentFilter.types = message.types;
            } else {
                currentFilter.types = null;
            }
        }

        loadShips();
    }

    loadPorts();
    loadShips();

    setInterval(loadPorts, 5000);
    setInterval(loadShips, 5000);

</script>
</body>
</html>